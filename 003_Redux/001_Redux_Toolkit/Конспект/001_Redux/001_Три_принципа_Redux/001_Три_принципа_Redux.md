# 001_Три_принципа_Redux

<https://redux.js.org/understanding/thinking-in-redux/three-principles>

Первый принцип гласит о том что у нашего проекта должен быть единый источник правды. Единый источник правды предполагает что у нас есть какой-то единый глобальный state, некое глобальное хранилище, информация о котором потребляется нашими компонентами и при этом не дублируется в самих компонентах. Т.е. не так что мы локально в компоненте храним какую-то информацию и эту же информацию храним в redux и как-то пытаемся их между собой синхронизировать. НЕТ НАМ ГОВОРЯТ ЕДИНЫЙ ИСТОЧНИК ИСТИНЫ.

У нас будет некий какой-то глобальный объект store, который представляет собой некий большой объект с вложенными элементами.

Однако здесь тоже стоит сделать ремарку что все то что в React мы хранили в state через useState, либо state в классовых компонентах, то мы от них вообще отказываемся и все переносим в redux. Это на самом деле не так. Но вся та информация которая должна разделяться между разными компонентами в большинстве своем будет храниться именно в Redux.


<br/>
<br/>
<br/>

Следующее превило представляет собой информацию о том что наш state дается только для чтения. Компонент потребляет информацию которая есть в объекте store. Читает ее, но не может ее модифицировать ее напрямую. Мы не мутируем, мы не перезаписываем значение напрямую.

Перезаписывать мы будем через специальные сущности. Только через actions мы можем как то видоизменить наше состояние приложения. При чем в данном случае логику actions мы будем писать не в самих компонентах. В компонентах мы будем просто вызывать эти события.


<br/>
<br/>
<br/>

Ну и третье правило оно касается непосредственно обработки. Обрабатываются наши actions в такой сущности как reducer. И сдесь для нас есть важная ремерка, эти функции должны быть чистыми.

Чисты функции говорят нам о том что они ведут себя предсказуемо. Они одинаково должны выдавать результат при одинаково входных данных. Т.е. они получив в параметрах два одинаковых значения, а выходе длжны вернуть два одинаковых результата.

Кроме того чистые функции не имеют side эффектов. Полученные объекты буд то state, они их не мутируют, так же только читают. Они не обращаются к БД, они не обращаются к localStorage. Ну и прочие side эффекты.

В целом наша задача будет стримится к иммутабельности. Стремится к тому что бы не мутировать ни какую информацию из state.

В принципе информация об иммутабельности актуальна и если мы просто работаем с обычным state в React. Для того что бы не мутировать значение state, т.е. не обращаться к нему через точку, в классовых компонентах мы использовали функцию setState и меняли бы какое-то значение.

Здесь у redux свой подход. Мы будем использовать action и reducer